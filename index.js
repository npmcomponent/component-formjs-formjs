// Generated by CoffeeScript 1.4.0
(function() {
  var Form,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Form = (function() {

    Form.types = {};

    Form.used_ids = [];

    function Form(obj) {
      if (obj._method) {
        obj._type = 'form';
      }
      this.dom = this.render(obj);
    }

    Form.prototype._filter = function(obj, match) {
      var key, ret, val;
      ret = {};
      for (key in obj) {
        val = obj[key];
        if (key.match(match)) {
          ret[key] = val;
        }
      }
      return ret;
    };

    Form.prototype.getAttributes = function(obj) {
      return this._filter(obj, /^_/);
    };

    Form.prototype.getChildren = function(obj) {
      var child, children, name;
      children = this._filter(obj, /^[a-z0-9]/i);
      for (name in children) {
        child = children[name];
        children[name]._parent = obj;
        children[name]._name = child._name || name;
      }
      return children;
    };

    Form.prototype.render = function(obj) {
      var children, element, name, val;
      element = this._render(obj);
      if (!obj._nowrap) {
        element = this.label(this._wrap(element), obj);
      }
      children = this.getChildren(obj);
      for (name in children) {
        val = children[name];
        this.render(val).appendTo(element);
      }
      return element;
    };

    Form.prototype._render = function(obj, type_override) {
      var fn, type;
      if (type_override == null) {
        type_override = null;
      }
      type = type_override || obj._type;
      fn = Form.types[type] || Form.types["default"];
      return fn.call(this, obj);
    };

    Form.prototype._generate_id = function(obj) {
      var id, ids;
      if (!obj._id) {
        id = "form-" + obj._name;
        ids = Form.used_ids;
        while (__indexOf.call(Form.used_ids, id) >= 0) {
          id = "form-" + obj._name + "-" + (Math.random());
        }
        Form.used_ids.push(id);
        return obj._id = id;
      }
    };

    Form.prototype.label = function(ele, obj) {
      if (obj._label) {
        this._generate_id(obj);
        jQuery('<label />').attr({
          'for': obj._id
        }).text(obj._label).prependTo(ele);
      }
      return ele;
    };

    Form.prototype.applyAttributes = function(ele, _attrs) {
      var attrs, cb, ev, events, k, v, _ref;
      attrs = ele._attributes || {};
      _ref = this.getAttributes(_attrs);
      for (k in _ref) {
        v = _ref[k];
        if (!(k !== '_nowrap' && k !== '_attributes' && k !== '_parent' && k !== '_events')) {
          continue;
        }
        k = k.substr(1);
        if (!(attrs[k] != null)) {
          attrs[k] = v;
        }
      }
      ele.attr(attrs);
      if (events = _attrs._events) {
        for (ev in events) {
          cb = events[ev];
          if (!(ev)) {
            continue;
          }
          if (!(cb.forEach != null)) {
            cb = [cb];
          }
          if (ev === 'submit' && events.validate) {
            cb.unshift(events.validate);
          }
          if (ev === 'validate') {
            if (!events.submit) {
              ev = 'submit';
            } else {
              continue;
            }
          }
          ele[ev](function() {
            var _cb, _i, _len;
            for (_i = 0, _len = cb.length; _i < _len; _i++) {
              _cb = cb[_i];
              if (!_cb.apply(this, arguments)) {
                return false;
              }
            }
          });
        }
      }
      return ele;
    };

    Form.prototype._wrap = function(ele) {
      return jQuery(ele).wrap('<div />').parent().addClass('form-row');
    };

    Form.registerType = Form.prototype.registerType = function(type, callback) {
      return Form.types[type] = callback;
    };

    return Form;

  })();

  /*
  Type: form
  */


  Form.registerType('form', function(options) {
    options._nowrap = true;
    options._attributes = {
      type: false
    };
    return this.applyAttributes(jQuery('<form />'), options);
  });

  /*
  Type: fieldset
  Options:
  	legend: text to appear in a <legend> tag as the first child of the fieldset
  */


  Form.registerType('fieldset', function(options) {
    var tag;
    options._nowrap = true;
    tag = this.applyAttributes(jQuery('<fieldset>'), options);
    if (options._legend) {
      tag.removeAttr('legend');
      jQuery('<legend>').html(options._legend).appendTo(tag);
    }
    return tag;
  });

  /*
  Type: group
  Notes: wraps a set of elements without using a fieldset
  */


  Form.registerType('group', function(options) {
    options._nowrap = true;
    return this.applyAttributes(jQuery('<div />'), options);
  });

  /*
  Type: description
  Notes: Mostly used internally to add descriptions to an existing element
  Options:
  	description/text: text to appear in the description
  */


  Form.registerType('description', function(options) {
    options._nowrap = true;
    return this.applyAttributes(jQuery('<span />').addClass('description').html(options._description || options._text));
  });

  /*
  Type: markup
  Notes: Used to display markup, ie white-space: pre
  Options:
  	markup/text: text to appear inside
  */


  Form.registerType('markup', function(options) {
    return this.applyAttributes(jQuery('<div />').html(options._markup || options.text));
  });

  /*
  Type: hidden
  Notes: A type=hidden input
  */


  Form.registerType('hidden', function(options) {
    options._nowrap = true;
    return Form.types["default"](options);
  });

  /*
  Type: textarea
  Notes: A <textarea /> input
  Options: _cols, _rows
  */


  Form.registerType('textarea', function(options) {
    var tag;
    tag = jQuery('<textarea />').html(options._value);
    delete options._value;
    return this.applyAttributes(tag, options);
  });

  /*
  Type: select
  Notes: A dropdown <select> element
  Options:
  	_options: a hashmap of value and labels
  	_multiple: boolean wether the "multiple" attribute should be set
  */


  Form.registerType('select', function(options) {
    var label, opt, tag, val;
    if (options._multiple && (options._multiple === !!options._multiple)) {
      options._multiple = 'multiple';
    } else {
      delete options._multiple;
    }
    tag = jQuery('<select />');
    for (val in options) {
      label = options[val];
      opt = jQuery('<option />').attr('value', val).html(label);
      if (val === options._value) {
        opt.attr('selected', 'selected');
      }
      opt.appendTo(tag);
    }
    return this.applyAttributes(tag, options);
  });

  /*
  Type: button
  Notes: A <button> tag
  Options: _value
  */


  Form.registerType('button', function(options) {
    return this.applyAttributes(jQuery('<button />').html(options._value));
  });

  /*
  Type: default
  Notes: fallback used to implement text/radio/submit etc <input type=".." without strictly defining them
  */


  Form.registerType('default', function(options) {
    return this.applyAttributes(jQuery('<input />'), options);
  });

  module.exports = Form;

}).call(this);
